# 智能合约的ABI

##智能合约是什么	

​	智能合约是在区块链上运行的应用或程序。通常情况下，它们为一组具有特定规则的数字化协议，且该协议能够被强制执行。这些规则由计算机源代码预先定义，网络节点会复制和执行这些计算机源码。

​	简单的说，智能合约就是区块链上一个包含合约代码和存储空间的虚拟账户。

​	智能合约的行为由合约代码控制，而智能合约的账户存储则保存了合约的状态。

​	在以太坊平台上，智能合约的代码运行在以太坊虚拟机（ EVM ）中， EVM 是一个图灵完备的虚拟机，是以太坊协议的核心 。 

​	在以太坊的点对点（ P2P ）网络中，每个全节点上都包含一个以太坊虚拟机，当节点需要打包或验证区块时， 便将交易相关的可执行代码送入 EVM 中执行， 执行的结果更新了以太坊账户的状态并被记录在区块链上。

## 智能合约的操作

​	创建智能合约的流程：

1. 编写智能合约的代码

2. 编译智能合约的代码变成可以在EVM上执行的bytecode，同时可以通过编译获得智能合约的ABI

3. 部署到区块链，通过一个交易将bytecode存储在链上，并获得合约地址

   调用合约的流程：

​	发起一笔指向智能合约地址的交易，智能合约代码分布式地运行在网络中每个节点的以太坊虚拟机中，然后会获得交易的回执。回执保存交易的输入参数、输出、执行状态等。

举一个例子，首先在Remix平台编写一个智能合约Hello.sol

```go
pragma solidity >=0.4.21;

contract Hello{

    string message;
    
    event SetMessage(string _message);
    
    function set(string memory _message) public {
        message = _message;  
        emit SetMessage(_message);
    }

    function get() public view returns(string memory){
        return message;
    }
    
}
```

编译成字节码，发起一笔交易部署到区块链中，得到交易回执

![image-20201106155102618](/Users/vincent/Library/Application Support/typora-user-images/image-20201106155102618.png)

这样就成功的将合约部署到区块链网络中了。

## ABI是什么

​	上文提到调用智能合约，需要发起一笔指向合约地址的交易，以太坊节点会根据输入的信息，选择要执行合约中的哪一个函数和函数的参数。如何知道智能合约提供哪些函数以及参数要求呢，就需要用到ABI了。

​	合约ABI（Application Binary Interface）是在以太坊生态系统中与合约进行交互的标准方法，既可以从区块链外部进行，也可以用于合约间的交互。

​	ABI类似程序中的接口文档，描述了字段名称、字段类型、方法名称、参数名称、参数类型、方法返回值类型等。

通俗的解释：

1. **ABI是合约接口的说明**
2. **ABI定义与合约进行交互的数据编码解码规则**

以之前的Hello.sol为例，在编译合约的时候可以生成合约的ABI

```json
[
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": false,
				"internalType": "string",
				"name": "_message",
				"type": "string"
			}
		],
		"name": "SetMessage",
		"type": "event"
	},
	{
		"inputs": [],
		"name": "get",
		"outputs": [
			{
				"internalType": "string",
				"name": "",
				"type": "string"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "string",
				"name": "_message",
				"type": "string"
			}
		],
		"name": "set",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	}
]
```

###ABI各参数的含义

- `name`：函数名称
- `type`：方法类型，包括 `function`、`event`等
- `payable`：布尔值，表明方法是否可以接受ether
- `stateMutability`：状态类型，包括`pure` (不读取区块链状态)，`view` (和constant类型，只能查看，不会修改合约字段)，`nonpayable`（和payable含义一样），`payable`（和payable含义一样）。
- `inputs`：数组，描述参数的名称和类型
  - `name`：参数名称
  - `type`：参数类型
- `outputs`：和`inputs`一样，如果没有返回值，缺省是一个空数组



​	当用户调用一个合约时，要对调用的函数名和传入的函数参数进行编码，这样EVM才能执行，知道用户调用的是哪个接口，以及正确读取用户的参数，下面介绍以太坊是如何生成可供EVM调用的字节码的。

​	生成的字节码主要分两部分：函数选择器和参数编码。

###函数选择器 Function Selector

​	函数调用的调用数据的前四个字节指定要调用的函数。它是通过将函数签名进行Keccak-256哈希运算后，取前四个字节得到的（高位顺序，左端为高位）。

以Hello.sol为例，set函数的接口定义为

```
function set(string memory _message) public;
```

在python3环境下安装ethereum库

```python
> from ethereum.utils import sha3
> sha3("set(string)").hex()
'4ed3885e778f096a5fd9407b264b5478208ea71532d13d454b0307e5f1542101'
> sha3("set(string)")[0:4].hex()
'4ed3885e'
```

取前四个字节（一个字节=2个16进制字符）即：4ed3885e

### 参数编码 Argument Encoding

​	从第五个字节开始，后面是编码参数。参数的编码根据类型的不同，编码方式也有所区别。主要分为固定类型和动态类型。

1、固定类型

- `uint<m>`：M位的无符号整数类型,`0 < M <= 256`, `M % 8 == 0`，如 `uint32`, `uint8`, `uint256`.。
- `int<M>` :M位的两个补码有符号整数类型.`0 < M <= 256`, `M % 8 == 0`.
- `uint`和`int`：整型，分别是`uint256`和`int256`的别名。注意: 函数参数类型是uint，转sha3码时要变成`uint256`。
- `address`：地址，20个字节，160bits，等同于`uint160`。
- `bool`：布尔类型，1个字节，true:1，false:0
- `bytes<M>`：固定大小的字节数组，`0 < M <= 32`,byte都是bytes1的别名。

2、动态类型

- `bytes`：动态分配大小的字节数组
- `string`：动态大小UTF8编码的字符串
- `<type>[]`: 给定类型的元素的可变长度数组。
- `<type>[m]` 给定类型的元素的定长数组。

### 编码规则

​	固定类型的编码就很简单，直接将参数值转成32字节长度的16进制即可。需要注意的是：数字类型，不足32bytes时，如果是正数高位补0，如果是负数高位补1。布尔类型高位补0。字节类型、字符串类型在低位补全。
​	动态类型的编码稍微复杂点，如果是固定长度就不需要计算偏移量，如果是不定长度就需要先计算偏移量，并在最后加上长度和具体值的编码。下面举例说明。

### Example

给出如下合约，参考官方文档https://solidity.readthedocs.io/en/develop/abi-spec.html#function-selector-and-argument-encoding

```js
pragma solidity >=0.4.16 <0.8.0;

contract Foo {
    function bar(bytes3[2] memory) public pure {}
    function baz(uint32 x, bool y) public pure returns (bool r) { r = x > 32 || y; }
    function sam(bytes memory, bool, uint[] memory) public pure {}
}
```

#### 案例1

函数：`baz(uint32,bool)`
调用：`baz(69, true)`

- `0xcdcd77c0` :函数选择器，在python中通过```sha3("set(string)")[0:4].hex()``` 得到`0xcdcd77c0`
- `0x0000000000000000000000000000000000000000000000000000000000000045`，十进制69，转成16进制为45，因为是正数，高位补0至32bytes
- `0x0000000000000000000000000000000000000000000000000000000000000001`，bool类型，`true=1`，`false=0`，高位补0

最终的字节码为

`0xcdcd77c000000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000001`

会返回 `bool`类型. 在这个调用中，返回值是 `false`, 它的输出将是单字节数组`0x0000000000000000000000000000000000000000000000000000000000000000`

#### 案例2

函数：`bar(bytes3[2] memory)`
调用：`bar(["abc", "def"])`

- `0xfce353f6`：函数选择器，在python中通过```sha3("bar(bytes3[2])")[0:4].hex()``` 得到`0xfce353f6`
- 固定长度不需要计算偏移量
- `0x6162630000000000000000000000000000000000000000000000000000000000`，字符串`abc`转成16进制后为`616263`，低位补0
- `0x6465660000000000000000000000000000000000000000000000000000000000`，字符串`def`转成16进制后为`646566`，低位补0

字符串转16进制的python参考代码

```python
import binascii
s = 'abc'
str_16 = binascii.b2a_hex(s.encode('utf-8'))  # 字符串转16进制
print(str_16)
```

最终的字节码为

`0xfce353f661626300000000000000000000000000000000000000000000000000000000006465660000000000000000000000000000000000000000000000000000000000`

#### 案例3

函数：`sam(bytes, bool, uint[])`

调用：`sam("dave",true,[1,2,3]")`

- `a5643bf2`:函数选择器，在python中通过`sha3("sam(bytes,bool,uint256[])")[0:4].hex()`得到`a5643bf2`.请注意，将`uint`替换为其规范表示形式`uint256`。
- `0x0000000000000000000000000000000000000000000000000000000000000060`:动态类型，计算偏移量。这个的偏移量是指实际存储值的位置，由于这个函数有3个变量，那么实际存储值的位置就是第四个32bytes位置，也就是说偏移量等于`3*32bytes=96`，转成16进制后就是对应的值
- `0x0000000000000000000000000000000000000000000000000000000000000001`: 第二个参数，布尔值true
- `0x00000000000000000000000000000000000000000000000000000000000000a0`：动态类型，计算偏移量，这个偏移量就等于参数长度`3*32bytes`+前面的动态参数参数占有的长度（因为前面只有一个动态参数，所以这个长度就是`1*32bytes+1*32bytes`，`1*32bytes`是第一个动态参数长度所占的bytes数，`1*32bytes`是因为该函数中的第一个动态参数用一个32bytes就能涵盖），那么具体的值就是 `3*32bytes+(1*32bytes+1*32bytes)=5*32bytes=160`，转成16进制就是a0，高位补全就是对应的值
- `0x0000000000000000000000000000000000000000000000000000000000000004`: 第一个参数的数据部分，代表元素中字节数组的长度，在这种情况下为4。
- `0x6461766500000000000000000000000000000000000000000000000000000000`:“dave”的utf-8编码，填充为32字节。
- `0x0000000000000000000000000000000000000000000000000000000000000003`: 第三个参数的数据部分，代表数组中元素的个数，在这种情况下为3.
- `0x0000000000000000000000000000000000000000000000000000000000000001`:第三个参数的第一项。
- `0x0000000000000000000000000000000000000000000000000000000000000002`: 第三个参数的第二项。
- `0x0000000000000000000000000000000000000000000000000000000000000003`: 第三个参数的第三项。

最终的字节码为

`0xa5643bf20000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000464617665000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003`

综上所述，ABI是合约接口的说明，并定义了与合约进行交互的数据编码解码规则。

# 参考资料

https://academy.binance.com/zh/articles/what-are-smart-contracts

https://segmentfault.com/a/1190000016634359

https://cloud.tencent.com/developer/article/1328286

https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/articles/3_features/35_contract/abi_of_contract.html

http://www.jouypub.com/2018/437e42a5629ea0ccd567909c94abb4a4/